# 자바스크립트 이벤트(Event)

## 이벤트(event)

이벤트(event)는 말 그대로 어떤 사건을 의미한다. 브라우저에서의 이벤트가 발생한다는 것은 사용자가 마우스로 클릭했을 '때', 스크롤을 했을 '때', 필드의 내용을 바꾸었을 '때'와 같은 것을 의미한다.

## 이벤트 type

이벤트의 종류를 의미한다. resize, scroll, click 등. 브라우저는 사용자의 행동에 따라서 이미 약속되어 있는 이벤트를 제공한다.

- UI Event
- Keyboard Event
- Mouse Event
- Focus Event
- Form Event

자세한 사항은 [Event reference](https://developer.mozilla.org/en-US/docs/Web/Reference/Events)에서 확인할 수 있다.

## 이벤트 target

target은 이벤트가 발생하는 요소를 의미한다.

## event handler

이벤트가 발생했을 때 동작하는 코드를 의미한다. 각 이벤트 기능에 맞도록 올바른 함수명을 작성해야 한다.

## 이벤트 등록하기

이벤트 프로그래밍을 하기 위해서는 이벤트의 대상에 이벤트 핸들러를 등록해줘야 한다. 웹 브라우저에서는 아래와 같은 방법을 제공한다.

- HTML 이벤트 핸들러 방식 (인라인)

  ```js
  <input type="button" onclick="alert('Hello world');" value="button" />

  // 인라인 방식은 HTML의 정보로써의 가치를 저하시킬 수 있는 요인이므로 자주 사용되는 방법은 아니다.
  ```

- 프로퍼티 리스너 방식

이벤트 대상에 해당하는 객체의 프로퍼티로 이벤트를 등록하는 방식이다.

```js
let btn = document.querySelector("#myBtn");

btn.onclick = function () {
  console.log("Hi there");
};

btn.onclick = function () {
  console.log("Hi again");
};
```

- addEvntListener 메서드

```js
let btn = document.querySelector("#myBtn");

function event1() {
  console.log("Hi Codeit!");
}

function event2() {
  console.log("Hi again!");
}

// elem.addEventListener(event type, handler)
btn.addEventListener("click", event1);
btn.addEventListener("click", event2);

// elem.removeEventListener(event type, handler)
btn.removeEventListener("click", event2);

// 여러 개의 이벤트 핸들러를 작성할 수 있다는 큰 장점이 있다.
```

addEventListener 메서드의 두 번째 인자는 함수명을 그대로 작성해야 한다. `event1()`처럼 중괄호를 함께 작성하면 해당 함수가 즉시 실행되기 때문에 **함수명만 작성해야한다.**

위의 예제에서 함수명만 작성하게 되는 것은 **버튼이 클릭되었을 때, 이 함수를 호출하자.** 라는 것. 함수를 바로 즉시 호출하지 않았다는 것이다.

## 이벤트 객체

이벤트를 제대로 다루려면 어떤 일이 일어났는지 상세히 알아야 한다. 예를 들어 `click` 이벤트가 발생했을 때, 마우스 포인터는 어디에 있는지. `keydown` 이벤트가 발생했을 때, 어떤 키가 눌렸는지 등. 상세한 정보를 필요로 한다.

이벤트가 발생하면 브라우저는 이벤트 객체(event object)를 생성한다. 이벤트 객체 프로퍼티에는 이벤트에 관한 상세한 정보가 담겨져 있으며 이벤트 핸들러에 인수 형태로 전달한다.

아래는 이벤트 객체로부터 포인터 좌표 정보를 얻어내는 예시임.

```js
<input type="button" value="클릭해 주세요." id="elem">

<script>
  elem.onclick = function(event) {
    // 이벤트 타입과 요소, 클릭 이벤트가 발생한 좌표를 보여줌
    alert(event.type + " 이벤트가 " + event.currentTarget + "에서 발생했습니다.");
    alert("이벤트가 발생한 곳의 좌표는 " + event.clientX + ":" + event.clientY +"입니다.");
  };
</script>
```

- [Event Object 프로퍼티 더 보기](https://developer.mozilla.org/en-US/docs/Web/API/Event)

## 이벤트 버블링과 캡처링

**이벤트 버블링**

한 요소에 이벤트가 발생하면, 해당 요소에 할당된 이벤트 핸들러가 동작하고 이어서 부모 요소의 핸들러가 동작된다. 가장 최상위의 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 해당된 이벤트 핸들러가 동작한다.

```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">
  FORM
  <div onclick="alert('div')">
    DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

위의 코드는 `form > div > p` 형태로 중첩된 구조이다. 요소 각각에는 핸들러가 할당되어 있고 가장 안 쪽의 `<p>` 태그를 클릭하면, `onclick` 핸들러가 동작하고 이어서 외부의 `<div>`에 할당된 핸들러 그리고 마지막으로는 `<form>`에 할당된 핸들러가 동작한다. 최상위의 `document` 객체를 만날 때까지 각 요소에 할당된 `onclick` 핸들러가 동작한다.

이런 이벤트 흐름 때문에 `<p>` 태그를 클릭하면, `p -> div -> form` 순서로 세 개의 alert 창이 뜨는 것이다.

이런 흐름을 `이벤트 버블링`이라고 하는데 이벤트가 가장 내부에 있는 요소부터 시작해서 부모 요소까지 거슬러 올라가면서 발생하는 모양이 마치 물속의 거품(bubble)과 닮았기 때문이다.

- 거의 모든 이벤트는 버블링 된다. cf. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있음.

**event.target**

이벤트가 발생한 가장 안 쪽의 요소는 타깃(target) 요소라고 불리고 `event.target`을 통해 접근할 수 있다.

**cf. event.target과 this(=event.currentTarget)의 차이**

간단하게 정리해서 `event.currentTarget`은 이벤트 핸들러가 부착된 부모 요소를 반환하고 `event.target`은 부모로부터 이벤트가 위임되어 발생하는 자식의 위치, 즉 내가 직접 클릭한 자식 요소를 반환하는 것이다.

**이벤트 캡처링**

[capturing](./../images/eventflow.svg)

**이벤트 위임**
